{
  "hash": "037225cd0c691f3765f1cac94f67f131",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"NumPy 개념정리\"\ndate : \"2025-03-07\"\nauthor: \"Jiwon Shin\"\ncategories: [news, code, analysis]\nimage: \"NumPy-and-Python.avif\"\n---\n\n\n\n\n\n## 넘파이 활용하기(배운것 정리)\n\n\n### NumPy 배열 생성\n\n::: {#62609b81 .cell execution_count=1}\n``` {.python .cell-code}\n# 벡터 생성하기 예제\nimport numpy as np\n\na = np.array([1, 2, 3, 4, 5]) # 숫자형 벡터 생\nb = np.array([\"apple\", \"banana\", \"orange\"])\nc = np.array([True, False, True, True]) #\nprint(\"Numeric Vector:\", a)\nprint(\"String Vector:\", b)\nprint(\"Boolean Vector:\", c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumeric Vector: [1 2 3 4 5]\nString Vector: ['apple' 'banana' 'orange']\nBoolean Vector: [ True False  True  True]\n```\n:::\n:::\n\n\n#### 빈 배열 선언 후 채우기\n\n빈 배열 생성하기 - np.empty() or np.zeros()\n\n::: {#8a1b5e3b .cell execution_count=2}\n``` {.python .cell-code}\n# 빈 배열 생성\nx = np.empty(3)\nprint(\"빈 벡터 생성하기:\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n빈 벡터 생성하기: [0.  0.5 1. ]\n```\n:::\n:::\n\n\n#### 배열을 생성하며 채우기\n\nnp.arange() - 일정한 간격으로 숫자를 생성하여 반환\n\n1. 0부터 10미만까지의 정수 배열 생성\n\n::: {#8e6d0d87 .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\n\narr1 = np.arange(10)\nprint(\"Array from 0 to 9:\", arr1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArray from 0 to 9: [0 1 2 3 4 5 6 7 8 9]\n```\n:::\n:::\n\n\n2. 0부터 2미만까지 0.5간격으로 배열 생성\n\n::: {#c5037eba .cell execution_count=4}\n``` {.python .cell-code}\narr2 = np.arange(0, 2, 0.5)\nprint(\"0부터 1.5가지 0.5 간격으로 발생:\", arr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0부터 1.5가지 0.5 간격으로 발생: [0.  0.5 1.  1.5]\n```\n:::\n:::\n\n\n3. 각 요소를 반복\n각 요소를 개별적으로 반복 - np.repeat()\n\n::: {#b625f4e1 .cell execution_count=5}\n``` {.python .cell-code}\n# 배열 [1, 2, 4]의 각 요소를 각각 1, 2, 3번 반복\nrepeated_each = np.repeat([1, 2, 4], repeats=[1, 2, 3])\nprint(\"Repeated each element in [1, 2, 4] two times:\", repeated_each)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRepeated each element in [1, 2, 4] two times: [1 2 2 4 4 4]\n```\n:::\n:::\n\n\n4. 백터 전체를 반복해서 붙이기\n백터 전체를 반복 - np.tile()\n\n::: {#2497723c .cell execution_count=6}\n``` {.python .cell-code}\n# 배열 [1, 2, 4]를 2번 반복\nrepeated_whole = np.tile([1, 2, 4], 2)\nprint(\"벡터 전체를 두번 반복:\", repeated_whole)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n벡터 전체를 두번 반복: [1 2 4 1 2 4]\n```\n:::\n:::\n\n\n### NumPy 벡터길이 재는 방법 \n\n#### len() 함수 사용하기\n\n배열의 첫번째 차원의 길이를 반환\n\n::: {#eac8afcf .cell execution_count=7}\n``` {.python .cell-code}\nimport numpy as np\n# 1차원 배열\na = np.array([1, 2, 3, 4, 5])\nlen(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n5\n```\n:::\n:::\n\n\n#### shape 속성 사용하기\nshape속성은 배열의 각 차원의 크기를 튜플 형태로 반환\n\n::: {#803bb94a .cell execution_count=8}\n``` {.python .cell-code}\nimport numpy as np\n\n# 1차원 배열\na = np.array([1, 2, 3, 4, 5])\na.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n(5,)\n```\n:::\n:::\n\n\n#### 배열의 전체 요소 수 구하기\nsize 속성은 배열의 전체 요소 수를 구함\n\n::: {#8b351e26 .cell execution_count=9}\n``` {.python .cell-code}\nimport numpy as np\n\n\na = np.array([1, 2, 3, 4, 5])\na.size\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n5\n```\n:::\n:::\n\n\n## NumPy를 사용하여 벡터 연산하기\n\n백터간 덧셈, 뺼셈, 곱셈, 나눗셈 등의 연산은 벡터의 각 요소에 동시 수행됨\n\n::: {#f89f7fa3 .cell execution_count=10}\n``` {.python .cell-code}\nimport numpy as np\n\n# 벡터 생성\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\n\n# 벡터 간 덧셈\nadd_result = a + b\nprint(\"벡터 덧셈:\", add_result)\n\n# 벡터 간 뺄셈\nsub_result = a - b\nprint(\"벡터 뺄셈:\", sub_result)\n\n# 벡터 간 곱셈\nmul_result = a * b\nprint(\"벡터 곱셈:\", mul_result)\n\n# 벡터 간 나눗셈\ndiv_result = a / b\nprint(\"벡터 나눗셈:\", div_result)\n\n# 벡터 간 나머지 연산\nmod_result = a % b\nprint(\"벡터 나머지 연산:\", mod_result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n벡터 덧셈: [5 7 9]\n벡터 뺄셈: [-3 -3 -3]\n벡터 곱셈: [ 4 10 18]\n벡터 나눗셈: [0.25 0.4  0.5 ]\n벡터 나머지 연산: [1 2 3]\n```\n:::\n:::\n\n\n## 백터화(Vectorized) 코드\n반복문을 사용하지 않고 벡터를 한 번에 처리할 수 있게 해준다.\n\n이를 통해 여러 값을 동시에 처리 할 수 있고, 가독성과 성능을 높인다.\n\n::: {#e39ec26f .cell execution_count=11}\n``` {.python .cell-code}\nimport numpy as np\n\n# 백터 덧셈셈\na = np.array([1, 2, 4])\nb = np.array([2, 3, 5])\nc = a + b\nprint(\"벡터 덧셈:\", c)\n\n\n# 상수 곱셈\nx = np.array([1, 2, 4, 5])\ny = x * 2\nprint(\"상수 곱셈:\", y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n벡터 덧셈: [3 5 9]\n상수 곱셈: [ 2  4  8 10]\n```\n:::\n:::\n\n\n## NumPy의 브로드캐스팅(Broadcasting)\n길이가 다른 배열 간의 연산을 가능하게 해주는 메커니즘\n\n#### 브로드캐스팅의 기본 원리\n두배열이 차원을 비교할 떄, 끝 차원부터 시작하여 앞으로 진행함\n\n연산이 가능하려면:\n\n1. 차원의 크기가 같거나 \n2. 차원 중 하나의 크기가 1인 경우 \n\n#### 브로드캐스팅이 안되는 경우\n배열의 shape을 맞춰 계산 가능함. \n\n이 경우 shape을 맞춰서 연산이 가능!\n\n\n#### 브로드캐스팅 되는 경우\nEx- 2차원 배열과 1차원 배열의 덧셈\n\n::: {#0e9828bf .cell execution_count=12}\n``` {.python .cell-code}\nimport numpy as np\n# 2차원 배열 생성\nmatrix = np.array([[ 0.0, 0.0, 0.0],\n[10.0, 10.0, 10.0],\n[20.0, 20.0, 20.0],\n[30.0, 30.0, 30.0]])\n# 1차원 배열 생성\nvector = np.array([1.0, 2.0, 3.0])\nprint(matrix.shape, vector.shape)\n\n# 브로드캐스팅을 이용한 배열 덧셈\nresult = matrix + vector\nprint(\"브로드캐스팅 결과:\\n\", result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(4, 3) (3,)\n브로드캐스팅 결과:\n [[ 1.  2.  3.]\n [11. 12. 13.]\n [21. 22. 23.]\n [31. 32. 33.]]\n```\n:::\n:::\n\n\n#### 벡터 내적 활용하기\ndot product(백터 내적)은 두 벡터의 요소를 곱한 후 합산하는 연산\n\n::: {#e405df86 .cell execution_count=13}\n``` {.python .cell-code}\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\ndot_product = np.dot(a, b)\nprint(\"벡터 내적:\", dot_product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n벡터 내적: 32\n```\n:::\n:::\n\n\n#### NumPy 벡터 슬라이싱\n벡터 일부 추출 시 [] 사용\n\n::: {#9725770f .cell execution_count=14}\n``` {.python .cell-code}\nimport numpy as np\n# 벡터 슬라이싱 예제, a를 랜덤하게 채움\nnp.random.seed(42)\na = np.random.randint(1, 21, 10)\nprint(a)\n\nprint(a[1]) # 두 번째 값 추출\n\nprint(a[1:4]) # 인덱스 1부터 3까지 추출; 4는 미포함\n\nprint(a[::2]) #첫번째, 세번째, 다섯번째(2씩 커지며 전체범위 지정)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 7 20 15 11  8  7 19 11 11  4]\n20\n[20 15 11]\n[ 7 15  8 19 11]\n```\n:::\n:::\n\n\n### 조건을 만족하는 위치 탐색 np.where()\nnp.where()함수를 이용하여 논리값이 TRUE 인 원소의 위치를 반환하는 역활을 함. \n\n::: {#7fb62860 .cell execution_count=15}\n``` {.python .cell-code}\nimport numpy as np\na = np.array([1, 5, 7, 8, 10]) # 예시 배열\nresult = np.where(a < 7)\nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n(array([0, 1], dtype=int64),)\n```\n:::\n:::\n\n\n### 벡터 함수 사용하기 \n평균, 합계, 중앙값, 표준편차를 계산 할수 있음\n\n::: {#f3468a8d .cell execution_count=16}\n``` {.python .cell-code}\nimport numpy as np\n\n# 벡터 함수 사용하기 예제\na = np.array([1, 2, 3, 4, 5])\nsum_a = np.sum(a) # 합계 계산\nmean_a = np.mean(a) # 평균 계산\nmedian_a = np.median(a) # 중앙값 계산\nstd_a = np.std(a, ddof=1) # 표준편차 계산\nsum_a, mean_a, median_a, std_a\n\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n(15, 3.0, 3.0, 1.5811388300841898)\n```\n:::\n:::\n\n\n### 빈 칸을 나타내는 방법\n#### 데이터가 정의 되지 않은 값 np.nan()\n\n::: {#af7e7117 .cell execution_count=17}\n``` {.python .cell-code}\nimport numpy as np\na = np.array([20, np.nan, 13, 24, 309])\na\n\n\n# nan 무시 옵션\nnp.nanmean(a) # nan 무시 함수\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n91.5\n```\n:::\n:::\n\n\n#### 데이터값이 없음을 나타내는 None\nNone은 아무런 값도 없는 상태를 나타냄.\n# None + 1   수치연산 불가(Typeerror 반환)\n\n\n\n### 여러 벡터들을 묶기\nnp.concatenate()  함수 사용\n\n::: {#e3c2a83e .cell execution_count=18}\n``` {.python .cell-code}\nimport numpy as np\nstr_vec = np.array([\"사과\", \"배\", \"수박\", \"참외\"])\nstr_vec\n\nmix_vec = np.array([\"사과\", 12, \"수박\", \"참외\"], dtype=str)\nmix_vec\n\ncombined_vec = np.concatenate((str_vec, mix_vec))\ncombined_vec\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\narray(['사과', '배', '수박', '참외', '사과', '12', '수박', '참외'], dtype='<U2')\n```\n:::\n:::\n\n\nnp.column_stack()와 np.row_stack()\n\n::: {#ff149c16 .cell execution_count=19}\n``` {.python .cell-code}\ncol_stacked = np.column_stack((np.arange(1, 5), np.arange(12, 16)))\ncol_stacked  # 벡터들을 세로로 배열\n\n\nrow_stacked = np.row_stack((np.arange(1, 5), np.arange(12, 16)))\nrow_stacked  # 벡터들을 가로로 배열\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\narray([[ 1,  2,  3,  4],\n       [12, 13, 14, 15]])\n```\n:::\n:::\n\n\n#### 길이가 다른 벡터 합치기\nnp.resize() 함수를 사용하면 길이를 강제로 맞춰줌. \n\n::: {#aeacb9d6 .cell execution_count=20}\n``` {.python .cell-code}\nimport numpy as np\n\n# 길이가 다른 벡터\nvec1 = np.arange(1, 5)\nvec2 = np.arange(12, 18)\nvec1 = np.resize(vec1, len(vec2))\nvec1\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\narray([1, 2, 3, 4, 1, 2])\n```\n:::\n:::\n\n\n### 여러 조건을 처리하기 - numpy.select()\n각 조건에 대한 결과를 리스트로 작성하여 조건에 따라 결과를 반환할 수 있음. \n\n::: {#5b4e1357 .cell execution_count=21}\n``` {.python .cell-code}\nimport numpy as np\n\nx = np.array([1, -2, 3, -4, 0])\nconditions = [x > 0, x == 0, x < 0]\nchoices = [\"양수\", \"0\", \"음수\"]\nresult = np.select(conditions, choices, default=\"기타\") # 기본값을 문자열로 설정\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['양수' '음수' '양수' '음수' '0']\n```\n:::\n:::\n\n\n### 메모리 절약을 위한 데이터 타입 설정(dtype)\nNumpy 배열 생성할 떄, 기본적으로 float64 타입 사용  \nBut, float32 or int32 작은 데이터를 사용하면 메모리를 절약 할 수 있음\n\n::: {#4e850c1e .cell execution_count=22}\n``` {.python .cell-code}\nimport numpy as np\n\na = np.array([1.0, 2.0, 3.0], dtype=np.float64) # 기본 dtype: float64\nb = np.array([1.0, 2.0, 3.0], dtype=np.float32) # float32로 저장\nprint(\"float64 배열 크기:\", a.nbytes, \"bytes\") # 8 bytes * 3 = 24 bytes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfloat64 배열 크기: 24 bytes\n```\n:::\n:::\n\n\n### 행렬이란?\n벡터들을 사용하여 만들 수 있는 객체\n\n#### 행렬 만들기\nnp.zeros() - 빈 행렬 생성, 사이즈만 지정\n\n::: {#9bd087f5 .cell execution_count=23}\n``` {.python .cell-code}\nimport numpy as np\n\n# 2행 2열 빈 행렬 생성\ny = np.zeros((2, 2))\nprint(\"빈 행렬 y:\\n\", y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n빈 행렬 y:\n [[0. 0.]\n [0. 0.]]\n```\n:::\n:::\n\n\n#### 채우면서 만들기\n\n::: {#7ebfb715 .cell execution_count=24}\n``` {.python .cell-code}\n# 1부터 4까지의 수로 채운 2행 2열 행렬 생성\ny = np.arange(1, 5).reshape(2, 2)\nprint(\"1부터 4까지의 수로 채운 행렬 y:\\n\", y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1부터 4까지의 수로 채운 행렬 y:\n [[1 2]\n [3 4]]\n```\n:::\n:::\n\n\n#### order 옵션\n'C' : 행 우선 순서\n\n'F' : 열 우선 순서\n\n::: {#3851c005 .cell execution_count=25}\n``` {.python .cell-code}\nimport numpy as np\n\n# 가로 방향으로 채우기 (기본값)\ny = np.arange(1, 5).reshape((2, 2), order='C')\nprint(\"가로 방향으로 채운 행렬 y:\\n\", y)\n\n\nimport numpy as np\n\n# 가로 방향으로 채우기\ny = np.arange(1, 5).reshape((2, 2), order='F')\nprint(\"가로 방향으로 채운 행렬 y:\\n\", y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n가로 방향으로 채운 행렬 y:\n [[1 2]\n [3 4]]\n가로 방향으로 채운 행렬 y:\n [[1 3]\n [2 4]]\n```\n:::\n:::\n\n\n### 행렬 인덱싱\n\n::: {#3c64efc4 .cell execution_count=26}\n``` {.python .cell-code}\nimport numpy as np\n\n# 1부터 10까지의 수에 2를 곱한 값으로 5행 2열의 행렬 생성\nx = np.arange(1, 11).reshape((5, 2)) * 2\nprint(\"행렬 x:\\n\", x)\n\n# 1행 2열의 원소 접근\nelement = x[0, 1]\nprint(\"1행 2열의 원소:\", element)\n\n# 두번째 열의 모든 원소 반환\nsecond_column = x[:, 1]\nprint(\"두 번째 열의 모든 원소:\", second_column)\n\n# 세번째 행의 모든 원소 반환\nthird_row = x[2, :]\nprint(\"세 번째 행의 모든 원소:\", third_row)\n\n# 두 번째 열에서 두 번째, 세 번째, 다섯 번째 행의 원소 반환\nselected_elements = x[[1, 2, 4], 1]\nprint(\"두번째 열의 2, 3, 5번째 행의 원소: \\n\", selected_elements)\n\n# 두 번째 열의 원소가 15보다 큰 행의 첫 번째 열의 원소 반환\nfiltered_elements = x[x[:, 1] > 15, 0]\nprint(\"두 번째 열의 원소가 15보다 큰 행의 첫 번째 열의 원소:\\n\", filtered_elements)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n행렬 x:\n [[ 2  4]\n [ 6  8]\n [10 12]\n [14 16]\n [18 20]]\n1행 2열의 원소: 4\n두 번째 열의 모든 원소: [ 4  8 12 16 20]\n세 번째 행의 모든 원소: [10 12]\n두번째 열의 2, 3, 5번째 행의 원소: \n [ 8 12 20]\n두 번째 열의 원소가 15보다 큰 행의 첫 번째 열의 원소:\n [14 18]\n```\n:::\n:::\n\n\n### 사진은 행렬이다. \n\n::: {#25e5aad0 .cell execution_count=27}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n# 난수 생성하여 3x3 크기의 행렬 생성\nnp.random.seed(2024)\nimg1 = np.random.rand(3, 3)\n\n# 행렬을 이미지로 표시\nplt.figure(figsize=(10, 5)) # (가로, 세로) 크기 설정\nplt.imshow(img1, cmap='gray', interpolation='nearest')\nplt.colorbar()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-28-output-1.png){width=517 height=416}\n:::\n:::\n\n\n### 행렬의 연산\n\n#### 행렬 뒤집기(Transpose)\n주어진 행렬의 행과 열을 뒤집어 반환함. \n\n::: {#eb7fcc7f .cell execution_count=28}\n``` {.python .cell-code}\nimport numpy as np\n\n# 5행 2열의 행렬 생성\nx = np.arange(1, 11).reshape((5, 2)) * 2\nprint(\"원래 행렬 x:\\n\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n원래 행렬 x:\n [[ 2  4]\n [ 6  8]\n [10 12]\n [14 16]\n [18 20]]\n```\n:::\n:::\n\n\n#### 행렬의 곱셈(dot prodcut)\n행렬의 곱셍은 행렬 크기가 맞아야 가능함. \n\n::: {#d9f36644 .cell execution_count=29}\n``` {.python .cell-code}\n# 2행 3열의 행렬 y 생성\ny = np.arange(1, 7).reshape((2, 3))\nprint(\"행렬 y:\\n\", y)\nx.shape\ny.shape\n\n# 행렬곱 계산\ndot_product = x.dot(y)\nprint(\"행렬곱 x * y:\\n\", dot_product)\n\n# 행렬 곱셈 (matmul 사용)\nmatrix_product = np.matmul(x, y) # 행렬 곱셈 전용\nprint(\"행렬 곱셈 (matmul 사용):\\n\", matrix_product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n행렬 y:\n [[1 2 3]\n [4 5 6]]\n행렬곱 x * y:\n [[ 18  24  30]\n [ 38  52  66]\n [ 58  80 102]\n [ 78 108 138]\n [ 98 136 174]]\n행렬 곱셈 (matmul 사용):\n [[ 18  24  30]\n [ 38  52  66]\n [ 58  80 102]\n [ 78 108 138]\n [ 98 136 174]]\n```\n:::\n:::\n\n\n#### 원소별 곱셈\n행렬의 크기가 같은 경우, 각 원소별로 곱셈을 수행 할 수 있음\n\n::: {#41850c24 .cell execution_count=30}\n``` {.python .cell-code}\nz = np.arange(10, 14).reshape((2, 2))\n\ny = np.array([[1, 2], [3, 4]])\n\n# 원소별 곱셈 계산\nelementwise_product = y * z\nelementwise_product\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\narray([[10, 22],\n       [36, 52]])\n```\n:::\n:::\n\n\n#### 행렬의 역행렬\nnp.linalg.inv() - 함수 사용(행렬의 역행렬 반환)\n역행렬이 존재하지 않는 경우 오류 반환\n\n::: {#698f7e87 .cell execution_count=31}\n``` {.python .cell-code}\n# 2행 2열의 정사각행렬 y 생성\ny = np.array([[1, 2], [3, 4]])\n\n# 행렬 y의 역행렬 계산\ninverse_y = np.linalg.inv(y)\ninverse_y\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\narray([[-2. ,  1. ],\n       [ 1.5, -0.5]])\n```\n:::\n:::\n\n\n### NumPy 배열 기본 제공 함수들 \nsum()  \naxis = 0(열별 합계), axis = 1(행별 합계)  \n\n::: {#b58022ff .cell execution_count=32}\n``` {.python .cell-code}\nimport numpy as np\n\na = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(\"열별 합계:\", a.sum(axis=0))\nprint(\"행별 합계:\", a.sum(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n열별 합계: [5 7 9]\n행별 합계: [ 6 15]\n```\n:::\n:::\n\n\nmean()  \naxis = 0(열별 평균) axis = 1(행별 평균)\n\n::: {#9d2d73b2 .cell execution_count=33}\n``` {.python .cell-code}\nprint(\"열별 평균:\", a.mean(axis=0))\nprint(\"행별 평균:\", a.mean(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n열별 평균: [2.5 3.5 4.5]\n행별 평균: [2. 5.]\n```\n:::\n:::\n\n\nmax()  \naxis = 0(열별 최대값), axis = 1(행별 최대값)\n\n::: {#67f4f8bc .cell execution_count=34}\n``` {.python .cell-code}\nprint(\"열별 최댓값:\", a.max(axis=0))\nprint(\"행별 최댓값:\", a.max(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n열별 최댓값: [4 5 6]\n행별 최댓값: [3 6]\n```\n:::\n:::\n\n\nmin()  \naxis = 0(열별 최솟값), axis = 1(행별 최솟값)\n\n::: {#73aee9a7 .cell execution_count=35}\n``` {.python .cell-code}\nprint(\"열별 최솟값:\", a.min(axis=0))\nprint(\"행별 최솟값:\", a.min(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n열별 최솟값: [1 2 3]\n행별 최솟값: [1 4]\n```\n:::\n:::\n\n\nstd()  \nddof 옵션을 사용하여 자유도 조정 가능\n\n::: {#8634b15b .cell execution_count=36}\n``` {.python .cell-code}\n# ddof = 1은 n-1로 나누어준것을 표현함(표본 표준편차)\nprint(\"표본 표준편차 (ddof=1):\", a.std(ddof=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n표본 표준편차 (ddof=1): 1.8708286933869707\n```\n:::\n:::\n\n\nvar()  \nddof 옵션을 사용하여 자유도 조정 가능\n\n::: {#c2f8d112 .cell execution_count=37}\n``` {.python .cell-code}\nprint(\"표본 분산 (ddof=1):\", a.var(ddof=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n표본 분산 (ddof=1): 3.5\n```\n:::\n:::\n\n\ncumsum()  \n배열 원소들의 누적 합계를 반환  \naxis = 0(열별 누적합계), axis = 1(행별 누적합계)\n\n::: {#0d2436f1 .cell execution_count=38}\n``` {.python .cell-code}\nprint(\"열별 누적 합계:\", a.cumsum(axis=0))\nprint(\"행별 누적 합계:\", a.cumsum(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n열별 누적 합계: [[1 2 3]\n [5 7 9]]\n행별 누적 합계: [[ 1  3  6]\n [ 4  9 15]]\n```\n:::\n:::\n\n\ncumprod()  \n배열 원소들의 누적 곱을 반환  \naxis = 0(열별 누적 곱), axis = 1(행별 누적곱)\n\n::: {#fabb8173 .cell execution_count=39}\n``` {.python .cell-code}\nprint(\"열별 누적 곱:\", a.cumprod(axis=0))\nprint(\"행별 누적 곱:\", a.cumprod(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n열별 누적 곱: [[ 1  2  3]\n [ 4 10 18]]\n행별 누적 곱: [[  1   2   6]\n [  4  20 120]]\n```\n:::\n:::\n\n\nargmax()  \n배열 원소들 중 최댓값의 인덱스를 반환  \naxis = 0(열별 최댓값), axis = 1(행별 최댓값)\n\n::: {#880a8ee1 .cell execution_count=40}\n``` {.python .cell-code}\nprint(\"최댓값의 인덱스 (열별):\", a.argmax(axis=0))\nprint(\"최댓값의 인덱스 (행별):\", a.argmax(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n최댓값의 인덱스 (열별): [1 1 1]\n최댓값의 인덱스 (행별): [2 2]\n```\n:::\n:::\n\n\nargmin()  \n배열 원소들 중 최솟값의 인덱스를 반환  \naxis = 0(열별 최댓값의 인덱스), axis =1(행별 최댓값의 인덱스)\n\n::: {#d17781d4 .cell execution_count=41}\n``` {.python .cell-code}\nprint(\"최솟값의 인덱스 (열별):\", a.argmin(axis=0))\nprint(\"최솟값의 인덱스 (행별):\", a.argmin(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n최솟값의 인덱스 (열별): [0 0 0]\n최솟값의 인덱스 (행별): [0 0]\n```\n:::\n:::\n\n\nreshape()  \n배열 형상을 반환\n\n::: {#0efddf60 .cell execution_count=42}\n``` {.python .cell-code}\nb = np.array([1, 2, 3, 4, 5, 6])\nprint(\"형상 변경:\\n\", b.reshape((2, 3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n형상 변경:\n [[1 2 3]\n [4 5 6]]\n```\n:::\n:::\n\n\ntranspose()  \n배열을 전치\n\n::: {#23d175c4 .cell execution_count=43}\n``` {.python .cell-code}\nc = np.array([[1, 2, 3], [4, 5, 6]])\nprint(\"전치 배열:\\n\", c.transpose())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n전치 배열:\n [[1 4]\n [2 5]\n [3 6]]\n```\n:::\n:::\n\n\nflatten()  \n1차원 배열로 전환\n\n::: {#98043b23 .cell execution_count=44}\n``` {.python .cell-code}\nprint(\"1차원 배열:\\n\", c.flatten())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1차원 배열:\n [1 2 3 4 5 6]\n```\n:::\n:::\n\n\nclip()  \n배열의 각 원소들을 주어진 최소값과 최대값의 범위로 자르는 역활을 함.\n\n::: {#6f177fd2 .cell execution_count=45}\n``` {.python .cell-code}\nd = np.array([1, 2, 3, 4, 5])\nprint(\"클립된 배열:\", d.clip(2, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n클립된 배열: [2 2 3 4 4]\n```\n:::\n:::\n\n\ntolist()  \n배열을 리스트로 변환\n\n::: {#d573160d .cell execution_count=46}\n``` {.python .cell-code}\nprint(\"리스트:\", d.tolist())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n리스트: [1, 2, 3, 4, 5]\n```\n:::\n:::\n\n\nastype()  \n배열 원소들의 타입을 변환\n\n::: {#5ee7b815 .cell execution_count=47}\n``` {.python .cell-code}\ne = np.array([1.1, 2.2, 3.3])\nprint(\"정수형 배열:\", e.astype(int))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n정수형 배열: [1 2 3]\n```\n:::\n:::\n\n\ncopy()  \n배열의 복사본을 반환\n\n::: {#8561e121 .cell execution_count=48}\n``` {.python .cell-code}\nf = d.copy()\nprint(\"복사본 배열:\", f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n복사본 배열: [1 2 3 4 5]\n```\n:::\n:::\n\n\n#### 얕은/깊은 복사의 개념 이해하기\n변수 d와 f가 연결되어 있어 f의 값을 변경하게 되면,  \n연결되어있는 d의 값 역시 변화는 것을 알 수 있다.\n\n::: {#26634924 .cell execution_count=49}\n``` {.python .cell-code}\n# 얕은 복사\nimport numpy as np\nd = np.array([1, 2, 3, 4, 5])\nf = d\nf[0] = 10\n\nprint(\"d:\", d)\nprint(\"f:\", f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nd: [10  2  3  4  5]\nf: [10  2  3  4  5]\n```\n:::\n:::\n\n\nf의 값이 변해도 d값이 변하지 않는 독립적인 변수가 되었음. \n\n::: {#1b5a40a2 .cell execution_count=50}\n``` {.python .cell-code}\n# 깊은 복사\nimport numpy as np\nd = np.array([1, 2, 3, 4, 5])\nf = d.copy()\nf[0] = 10\nprint(\"d:\", d)\n\nprint(\"f:\", f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nd: [1 2 3 4 5]\nf: [10  2  3  4  5]\n```\n:::\n:::\n\n\nsort()\n배열을 정렬\n\n::: {#f16c9653 .cell execution_count=51}\n``` {.python .cell-code}\ng = np.array([3, 1, 2])\ng.sort()\nprint(\"정렬된 배열:\", g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n정렬된 배열: [1 2 3]\n```\n:::\n:::\n\n\nargsort()\n배열의 원소들을 정렬했을때 인덱스를 반환\n\n::: {#3987a8f6 .cell execution_count=52}\n``` {.python .cell-code}\nh = np.array([3, 1, 2])\nprint(\"정렬된 인덱스:\", h.argsort())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n정렬된 인덱스: [1 2 0]\n```\n:::\n:::\n\n\n### NumPy 배열에 apply함수 적용\n\napply_along_axis()  \n넘파이 배열에 함수를 적용\n\n::: {#9f048211 .cell execution_count=53}\n``` {.python .cell-code}\narray_3d = np.arange(1, 25).reshape(2, 4, 3).transpose(0, 2, 1)\nprint(array_3d)\n\n# 같은 위치에 있는 값들끼리 비교\ndef my_func(x):\n  return np.min(x)\nnp.apply_along_axis(my_func, axis=0, arr=array_3d)\n\n# 같은 깊이의 행별 최소값\nnp.apply_along_axis(my_func, axis=1, arr=array_3d)\n\n# 같은 깊이의 열별 최소값\nnp.apply_along_axis(my_func, axis=2, arr=array_3d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[[ 1  4  7 10]\n  [ 2  5  8 11]\n  [ 3  6  9 12]]\n\n [[13 16 19 22]\n  [14 17 20 23]\n  [15 18 21 24]]]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\narray([[ 1,  2,  3],\n       [13, 14, 15]])\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}