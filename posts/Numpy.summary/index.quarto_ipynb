{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"NumPy 개념정리\"\n",
        "date : \"2025-03-07\"\n",
        "author: \"Jiwon Shin\"\n",
        "categories: [news, code, analysis]\n",
        "image: \"NumPy-and-Python.avif\"\n",
        "---\n",
        "\n",
        "\n",
        "## 넘파이 활용하기(배운것 정리)\n",
        "\n",
        "\n",
        "### NumPy 배열 생성\n"
      ],
      "id": "136aa966"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 벡터 생성하기 예제\n",
        "import numpy as np\n",
        "\n",
        "a = np.array([1, 2, 3, 4, 5]) # 숫자형 벡터 생\n",
        "b = np.array([\"apple\", \"banana\", \"orange\"])\n",
        "c = np.array([True, False, True, True]) #\n",
        "print(\"Numeric Vector:\", a)\n",
        "print(\"String Vector:\", b)\n",
        "print(\"Boolean Vector:\", c)"
      ],
      "id": "272394cc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### 빈 배열 선언 후 채우기\n",
        "\n",
        "빈 배열 생성하기 - np.empty() or np.zeros()\n"
      ],
      "id": "cb940528"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 빈 배열 생성\n",
        "x = np.empty(3)\n",
        "print(\"빈 벡터 생성하기:\", x)"
      ],
      "id": "91f9fc65",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### 배열을 생성하며 채우기\n",
        "\n",
        "np.arange() - 일정한 간격으로 숫자를 생성하여 반환\n",
        "\n",
        "1. 0부터 10미만까지의 정수 배열 생성"
      ],
      "id": "2b8f4df5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "arr1 = np.arange(10)\n",
        "print(\"Array from 0 to 9:\", arr1)"
      ],
      "id": "f27d6549",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "2. 0부터 2미만까지 0.5간격으로 배열 생성"
      ],
      "id": "7ef27aeb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "arr2 = np.arange(0, 2, 0.5)\n",
        "print(\"0부터 1.5가지 0.5 간격으로 발생:\", arr2)"
      ],
      "id": "a24feb12",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "3. 각 요소를 반복\n",
        "각 요소를 개별적으로 반복 - np.repeat()"
      ],
      "id": "570677f6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 배열 [1, 2, 4]의 각 요소를 각각 1, 2, 3번 반복\n",
        "repeated_each = np.repeat([1, 2, 4], repeats=[1, 2, 3])\n",
        "print(\"Repeated each element in [1, 2, 4] two times:\", repeated_each)"
      ],
      "id": "85d4794a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "4. 백터 전체를 반복해서 붙이기\n",
        "백터 전체를 반복 - np.tile()"
      ],
      "id": "cd789813"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 배열 [1, 2, 4]를 2번 반복\n",
        "repeated_whole = np.tile([1, 2, 4], 2)\n",
        "print(\"벡터 전체를 두번 반복:\", repeated_whole)"
      ],
      "id": "88247ef3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### NumPy 벡터길이 재는 방법 \n",
        "\n",
        "#### len() 함수 사용하기\n",
        "\n",
        "배열의 첫번째 차원의 길이를 반환"
      ],
      "id": "d71fb186"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "# 1차원 배열\n",
        "a = np.array([1, 2, 3, 4, 5])\n",
        "len(a)"
      ],
      "id": "b6f4bda0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### shape 속성 사용하기\n",
        "shape속성은 배열의 각 차원의 크기를 튜플 형태로 반환\n"
      ],
      "id": "8c53a572"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "# 1차원 배열\n",
        "a = np.array([1, 2, 3, 4, 5])\n",
        "a.shape"
      ],
      "id": "0685c534",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### 배열의 전체 요소 수 구하기\n",
        "size 속성은 배열의 전체 요소 수를 구함\n"
      ],
      "id": "d355e67c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "\n",
        "a = np.array([1, 2, 3, 4, 5])\n",
        "a.size"
      ],
      "id": "a0bf3c97",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## NumPy를 사용하여 벡터 연산하기\n",
        "\n",
        "백터간 덧셈, 뺼셈, 곱셈, 나눗셈 등의 연산은 벡터의 각 요소에 동시 수행됨\n"
      ],
      "id": "3f6eba9f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "# 벡터 생성\n",
        "a = np.array([1, 2, 3])\n",
        "b = np.array([4, 5, 6])\n",
        "\n",
        "# 벡터 간 덧셈\n",
        "add_result = a + b\n",
        "print(\"벡터 덧셈:\", add_result)\n",
        "\n",
        "# 벡터 간 뺄셈\n",
        "sub_result = a - b\n",
        "print(\"벡터 뺄셈:\", sub_result)\n",
        "\n",
        "# 벡터 간 곱셈\n",
        "mul_result = a * b\n",
        "print(\"벡터 곱셈:\", mul_result)\n",
        "\n",
        "# 벡터 간 나눗셈\n",
        "div_result = a / b\n",
        "print(\"벡터 나눗셈:\", div_result)\n",
        "\n",
        "# 벡터 간 나머지 연산\n",
        "mod_result = a % b\n",
        "print(\"벡터 나머지 연산:\", mod_result)"
      ],
      "id": "99752adb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 백터화(Vectorized) 코드\n",
        "반복문을 사용하지 않고 벡터를 한 번에 처리할 수 있게 해준다.\n",
        "\n",
        "이를 통해 여러 값을 동시에 처리 할 수 있고, 가독성과 성능을 높인다.\n"
      ],
      "id": "eea489c7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "# 백터 덧셈셈\n",
        "a = np.array([1, 2, 4])\n",
        "b = np.array([2, 3, 5])\n",
        "c = a + b\n",
        "print(\"벡터 덧셈:\", c)\n",
        "\n",
        "\n",
        "# 상수 곱셈\n",
        "x = np.array([1, 2, 4, 5])\n",
        "y = x * 2\n",
        "print(\"상수 곱셈:\", y)"
      ],
      "id": "2e2f839b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## NumPy의 브로드캐스팅(Broadcasting)\n",
        "길이가 다른 배열 간의 연산을 가능하게 해주는 메커니즘\n",
        "\n",
        "#### 브로드캐스팅의 기본 원리\n",
        "두배열이 차원을 비교할 떄, 끝 차원부터 시작하여 앞으로 진행함\n",
        "\n",
        "연산이 가능하려면:\n",
        "\n",
        "1. 차원의 크기가 같거나 \n",
        "2. 차원 중 하나의 크기가 1인 경우 \n",
        "\n",
        "#### 브로드캐스팅이 안되는 경우\n",
        "배열의 shape을 맞춰 계산 가능함. \n",
        "\n",
        "이 경우 shape을 맞춰서 연산이 가능!\n",
        "\n",
        "\n",
        "#### 브로드캐스팅 되는 경우\n",
        "Ex- 2차원 배열과 1차원 배열의 덧셈"
      ],
      "id": "5dafb89c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "# 2차원 배열 생성\n",
        "matrix = np.array([[ 0.0, 0.0, 0.0],\n",
        "[10.0, 10.0, 10.0],\n",
        "[20.0, 20.0, 20.0],\n",
        "[30.0, 30.0, 30.0]])\n",
        "# 1차원 배열 생성\n",
        "vector = np.array([1.0, 2.0, 3.0])\n",
        "print(matrix.shape, vector.shape)\n",
        "\n",
        "# 브로드캐스팅을 이용한 배열 덧셈\n",
        "result = matrix + vector\n",
        "print(\"브로드캐스팅 결과:\\n\", result)"
      ],
      "id": "a198c136",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### 벡터 내적 활용하기\n",
        "dot product(백터 내적)은 두 벡터의 요소를 곱한 후 합산하는 연산\n"
      ],
      "id": "0dbda4a9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "a = np.array([1, 2, 3])\n",
        "b = np.array([4, 5, 6])\n",
        "dot_product = np.dot(a, b)\n",
        "print(\"벡터 내적:\", dot_product)"
      ],
      "id": "ab6464ad",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### NumPy 벡터 슬라이싱\n",
        "벡터 일부 추출 시 [] 사용\n"
      ],
      "id": "0d5e6898"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "# 벡터 슬라이싱 예제, a를 랜덤하게 채움\n",
        "np.random.seed(42)\n",
        "a = np.random.randint(1, 21, 10)\n",
        "print(a)\n",
        "\n",
        "print(a[1]) # 두 번째 값 추출\n",
        "\n",
        "print(a[1:4]) # 인덱스 1부터 3까지 추출; 4는 미포함\n",
        "\n",
        "print(a[::2]) #첫번째, 세번째, 다섯번째(2씩 커지며 전체범위 지정)"
      ],
      "id": "6c647a08",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 조건을 만족하는 위치 탐색 np.where()\n",
        "np.where()함수를 이용하여 논리값이 TRUE 인 원소의 위치를 반환하는 역활을 함. \n"
      ],
      "id": "5c599ccb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "a = np.array([1, 5, 7, 8, 10]) # 예시 배열\n",
        "result = np.where(a < 7)\n",
        "result"
      ],
      "id": "4d1a7106",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 벡터 함수 사용하기 \n",
        "평균, 합계, 중앙값, 표준편차를 계산 할수 있음"
      ],
      "id": "a0aa69b9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "# 벡터 함수 사용하기 예제\n",
        "a = np.array([1, 2, 3, 4, 5])\n",
        "sum_a = np.sum(a) # 합계 계산\n",
        "mean_a = np.mean(a) # 평균 계산\n",
        "median_a = np.median(a) # 중앙값 계산\n",
        "std_a = np.std(a, ddof=1) # 표준편차 계산\n",
        "sum_a, mean_a, median_a, std_a\n"
      ],
      "id": "610bf7ca",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 빈 칸을 나타내는 방법\n",
        "#### 데이터가 정의 되지 않은 값 np.nan()\n"
      ],
      "id": "fb0cd745"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "a = np.array([20, np.nan, 13, 24, 309])\n",
        "a\n",
        "\n",
        "\n",
        "# nan 무시 옵션\n",
        "np.nanmean(a) # nan 무시 함수"
      ],
      "id": "c66c881e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### 데이터값이 없음을 나타내는 None\n",
        "None은 아무런 값도 없는 상태를 나타냄.\n",
        "# None + 1   수치연산 불가(Typeerror 반환)\n",
        "\n",
        "\n",
        "\n",
        "### 여러 벡터들을 묶기\n",
        "np.concatenate()  함수 사용"
      ],
      "id": "77699cca"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "str_vec = np.array([\"사과\", \"배\", \"수박\", \"참외\"])\n",
        "str_vec\n",
        "\n",
        "mix_vec = np.array([\"사과\", 12, \"수박\", \"참외\"], dtype=str)\n",
        "mix_vec\n",
        "\n",
        "combined_vec = np.concatenate((str_vec, mix_vec))\n",
        "combined_vec"
      ],
      "id": "2dc49370",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "np.column_stack()와 np.row_stack()"
      ],
      "id": "ad373510"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "col_stacked = np.column_stack((np.arange(1, 5), np.arange(12, 16)))\n",
        "col_stacked  # 벡터들을 세로로 배열\n",
        "\n",
        "\n",
        "row_stacked = np.row_stack((np.arange(1, 5), np.arange(12, 16)))\n",
        "row_stacked  # 벡터들을 가로로 배열"
      ],
      "id": "d35e1a2b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### 길이가 다른 벡터 합치기\n",
        "np.resize() 함수를 사용하면 길이를 강제로 맞춰줌. "
      ],
      "id": "2ffee15f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "# 길이가 다른 벡터\n",
        "vec1 = np.arange(1, 5)\n",
        "vec2 = np.arange(12, 18)\n",
        "vec1 = np.resize(vec1, len(vec2))\n",
        "vec1"
      ],
      "id": "a9f2a777",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 여러 조건을 처리하기 - numpy.select()\n",
        "각 조건에 대한 결과를 리스트로 작성하여 조건에 따라 결과를 반환할 수 있음. "
      ],
      "id": "8ec494a8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "x = np.array([1, -2, 3, -4, 0])\n",
        "conditions = [x > 0, x == 0, x < 0]\n",
        "choices = [\"양수\", \"0\", \"음수\"]\n",
        "result = np.select(conditions, choices, default=\"기타\") # 기본값을 문자열로 설정\n",
        "print(result)"
      ],
      "id": "5c68f081",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 메모리 절약을 위한 데이터 타입 설정(dtype)\n",
        "Numpy 배열 생성할 떄, 기본적으로 float64 타입 사용  \n",
        "But, float32 or int32 작은 데이터를 사용하면 메모리를 절약 할 수 있음"
      ],
      "id": "c1897e8b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "a = np.array([1.0, 2.0, 3.0], dtype=np.float64) # 기본 dtype: float64\n",
        "b = np.array([1.0, 2.0, 3.0], dtype=np.float32) # float32로 저장\n",
        "print(\"float64 배열 크기:\", a.nbytes, \"bytes\") # 8 bytes * 3 = 24 bytes"
      ],
      "id": "c8e33594",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 행렬이란?\n",
        "벡터들을 사용하여 만들 수 있는 객체\n",
        "\n",
        "#### 행렬 만들기\n",
        "np.zeros() - 빈 행렬 생성, 사이즈만 지정"
      ],
      "id": "07fe6d7c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "# 2행 2열 빈 행렬 생성\n",
        "y = np.zeros((2, 2))\n",
        "print(\"빈 행렬 y:\\n\", y)"
      ],
      "id": "884cd79b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### 채우면서 만들기"
      ],
      "id": "89f0f76e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 1부터 4까지의 수로 채운 2행 2열 행렬 생성\n",
        "y = np.arange(1, 5).reshape(2, 2)\n",
        "print(\"1부터 4까지의 수로 채운 행렬 y:\\n\", y)"
      ],
      "id": "a57577d4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### order 옵션\n",
        "'C' : 행 우선 순서\n",
        "\n",
        "'F' : 열 우선 순서\n"
      ],
      "id": "1321a2d0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "# 가로 방향으로 채우기 (기본값)\n",
        "y = np.arange(1, 5).reshape((2, 2), order='C')\n",
        "print(\"가로 방향으로 채운 행렬 y:\\n\", y)\n",
        "\n",
        "\n",
        "import numpy as np\n",
        "\n",
        "# 가로 방향으로 채우기\n",
        "y = np.arange(1, 5).reshape((2, 2), order='F')\n",
        "print(\"가로 방향으로 채운 행렬 y:\\n\", y)"
      ],
      "id": "c1d7fef5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 행렬 인덱싱"
      ],
      "id": "d6415c26"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "# 1부터 10까지의 수에 2를 곱한 값으로 5행 2열의 행렬 생성\n",
        "x = np.arange(1, 11).reshape((5, 2)) * 2\n",
        "print(\"행렬 x:\\n\", x)\n",
        "\n",
        "# 1행 2열의 원소 접근\n",
        "element = x[0, 1]\n",
        "print(\"1행 2열의 원소:\", element)\n",
        "\n",
        "# 두번째 열의 모든 원소 반환\n",
        "second_column = x[:, 1]\n",
        "print(\"두 번째 열의 모든 원소:\", second_column)\n",
        "\n",
        "# 세번째 행의 모든 원소 반환\n",
        "third_row = x[2, :]\n",
        "print(\"세 번째 행의 모든 원소:\", third_row)\n",
        "\n",
        "# 두 번째 열에서 두 번째, 세 번째, 다섯 번째 행의 원소 반환\n",
        "selected_elements = x[[1, 2, 4], 1]\n",
        "print(\"두번째 열의 2, 3, 5번째 행의 원소: \\n\", selected_elements)\n",
        "\n",
        "# 두 번째 열의 원소가 15보다 큰 행의 첫 번째 열의 원소 반환\n",
        "filtered_elements = x[x[:, 1] > 15, 0]\n",
        "print(\"두 번째 열의 원소가 15보다 큰 행의 첫 번째 열의 원소:\\n\", filtered_elements)"
      ],
      "id": "77ee0a11",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 사진은 행렬이다. "
      ],
      "id": "26adae5c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# 난수 생성하여 3x3 크기의 행렬 생성\n",
        "np.random.seed(2024)\n",
        "img1 = np.random.rand(3, 3)\n",
        "\n",
        "# 행렬을 이미지로 표시\n",
        "plt.figure(figsize=(10, 5)) # (가로, 세로) 크기 설정\n",
        "plt.imshow(img1, cmap='gray', interpolation='nearest')\n",
        "plt.colorbar()\n",
        "plt.show()"
      ],
      "id": "1404baef",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 행렬의 연산\n",
        "\n",
        "#### 행렬 뒤집기(Transpose)\n",
        "주어진 행렬의 행과 열을 뒤집어 반환함. "
      ],
      "id": "d50f98fb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "# 5행 2열의 행렬 생성\n",
        "x = np.arange(1, 11).reshape((5, 2)) * 2\n",
        "print(\"원래 행렬 x:\\n\", x)"
      ],
      "id": "ef048144",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### 행렬의 곱셈(dot prodcut)\n",
        "행렬의 곱셍은 행렬 크기가 맞아야 가능함. \n"
      ],
      "id": "8757c459"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 2행 3열의 행렬 y 생성\n",
        "y = np.arange(1, 7).reshape((2, 3))\n",
        "print(\"행렬 y:\\n\", y)\n",
        "x.shape\n",
        "y.shape\n",
        "\n",
        "# 행렬곱 계산\n",
        "dot_product = x.dot(y)\n",
        "print(\"행렬곱 x * y:\\n\", dot_product)\n",
        "\n",
        "# 행렬 곱셈 (matmul 사용)\n",
        "matrix_product = np.matmul(x, y) # 행렬 곱셈 전용\n",
        "print(\"행렬 곱셈 (matmul 사용):\\n\", matrix_product)"
      ],
      "id": "d388c593",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### 원소별 곱셈\n",
        "행렬의 크기가 같은 경우, 각 원소별로 곱셈을 수행 할 수 있음\n"
      ],
      "id": "775941ea"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "z = np.arange(10, 14).reshape((2, 2))\n",
        "\n",
        "y = np.array([[1, 2], [3, 4]])\n",
        "\n",
        "# 원소별 곱셈 계산\n",
        "elementwise_product = y * z\n",
        "elementwise_product"
      ],
      "id": "fc3c478e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### 행렬의 역행렬\n",
        "np.linalg.inv() - 함수 사용(행렬의 역행렬 반환)\n",
        "역행렬이 존재하지 않는 경우 오류 반환"
      ],
      "id": "8db3048d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 2행 2열의 정사각행렬 y 생성\n",
        "y = np.array([[1, 2], [3, 4]])\n",
        "\n",
        "# 행렬 y의 역행렬 계산\n",
        "inverse_y = np.linalg.inv(y)\n",
        "inverse_y"
      ],
      "id": "68b406c9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### NumPy 배열 기본 제공 함수들 \n",
        "sum()  \n",
        "axis = 0(열별 합계), axis = 1(행별 합계)  \n"
      ],
      "id": "cae26084"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "a = np.array([[1, 2, 3], [4, 5, 6]])\n",
        "\n",
        "print(\"열별 합계:\", a.sum(axis=0))\n",
        "print(\"행별 합계:\", a.sum(axis=1))"
      ],
      "id": "c3d52e8f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "mean()  \n",
        "axis = 0(열별 평균) axis = 1(행별 평균)"
      ],
      "id": "5d556c37"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"열별 평균:\", a.mean(axis=0))\n",
        "print(\"행별 평균:\", a.mean(axis=1))"
      ],
      "id": "229b30e6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "max()  \n",
        "axis = 0(열별 최대값), axis = 1(행별 최대값)"
      ],
      "id": "5485e5f0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"열별 최댓값:\", a.max(axis=0))\n",
        "print(\"행별 최댓값:\", a.max(axis=1))"
      ],
      "id": "f88dff50",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "min()  \n",
        "axis = 0(열별 최솟값), axis = 1(행별 최솟값)"
      ],
      "id": "bad62d1f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"열별 최솟값:\", a.min(axis=0))\n",
        "print(\"행별 최솟값:\", a.min(axis=1))"
      ],
      "id": "37af5617",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "std()  \n",
        "ddof 옵션을 사용하여 자유도 조정 가능"
      ],
      "id": "f6b2637b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# ddof = 1은 n-1로 나누어준것을 표현함(표본 표준편차)\n",
        "print(\"표본 표준편차 (ddof=1):\", a.std(ddof=1))"
      ],
      "id": "639530df",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "var()  \n",
        "ddof 옵션을 사용하여 자유도 조정 가능"
      ],
      "id": "a3e6a911"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"표본 분산 (ddof=1):\", a.var(ddof=1))"
      ],
      "id": "d95c3030",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "cumsum()  \n",
        "배열 원소들의 누적 합계를 반환  \n",
        "axis = 0(열별 누적합계), axis = 1(행별 누적합계)"
      ],
      "id": "f2c63e3c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"열별 누적 합계:\", a.cumsum(axis=0))\n",
        "print(\"행별 누적 합계:\", a.cumsum(axis=1))"
      ],
      "id": "3eb8369f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "cumprod()  \n",
        "배열 원소들의 누적 곱을 반환  \n",
        "axis = 0(열별 누적 곱), axis = 1(행별 누적곱)"
      ],
      "id": "beafbdad"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"열별 누적 곱:\", a.cumprod(axis=0))\n",
        "print(\"행별 누적 곱:\", a.cumprod(axis=1))"
      ],
      "id": "241eaaec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "argmax()  \n",
        "배열 원소들 중 최댓값의 인덱스를 반환  \n",
        "axis = 0(열별 최댓값), axis = 1(행별 최댓값)"
      ],
      "id": "6263f427"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"최댓값의 인덱스 (열별):\", a.argmax(axis=0))\n",
        "print(\"최댓값의 인덱스 (행별):\", a.argmax(axis=1))"
      ],
      "id": "412020aa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "argmin()  \n",
        "배열 원소들 중 최솟값의 인덱스를 반환  \n",
        "axis = 0(열별 최댓값의 인덱스), axis =1(행별 최댓값의 인덱스)"
      ],
      "id": "060e373d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"최솟값의 인덱스 (열별):\", a.argmin(axis=0))\n",
        "print(\"최솟값의 인덱스 (행별):\", a.argmin(axis=1))"
      ],
      "id": "5d8f1fd4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "reshape()  \n",
        "배열 형상을 반환"
      ],
      "id": "f06edd34"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "b = np.array([1, 2, 3, 4, 5, 6])\n",
        "print(\"형상 변경:\\n\", b.reshape((2, 3)))"
      ],
      "id": "f614d468",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "transpose()  \n",
        "배열을 전치"
      ],
      "id": "b0f98b17"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "c = np.array([[1, 2, 3], [4, 5, 6]])\n",
        "print(\"전치 배열:\\n\", c.transpose())"
      ],
      "id": "f473cd8c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "flatten()  \n",
        "1차원 배열로 전환"
      ],
      "id": "514323c1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"1차원 배열:\\n\", c.flatten())"
      ],
      "id": "d0f6bee8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "clip()  \n",
        "배열의 각 원소들을 주어진 최소값과 최대값의 범위로 자르는 역활을 함."
      ],
      "id": "89ab3496"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "d = np.array([1, 2, 3, 4, 5])\n",
        "print(\"클립된 배열:\", d.clip(2, 4))"
      ],
      "id": "4b93494c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "tolist()  \n",
        "배열을 리스트로 변환"
      ],
      "id": "3de31ed1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"리스트:\", d.tolist())"
      ],
      "id": "e75555e8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "astype()  \n",
        "배열 원소들의 타입을 변환"
      ],
      "id": "3e2ff259"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "e = np.array([1.1, 2.2, 3.3])\n",
        "print(\"정수형 배열:\", e.astype(int))"
      ],
      "id": "f7ba52e6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "copy()  \n",
        "배열의 복사본을 반환"
      ],
      "id": "e329a48b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = d.copy()\n",
        "print(\"복사본 배열:\", f)"
      ],
      "id": "60351612",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### 얕은/깊은 복사의 개념 이해하기\n",
        "변수 d와 f가 연결되어 있어 f의 값을 변경하게 되면,  \n",
        "연결되어있는 d의 값 역시 변화는 것을 알 수 있다."
      ],
      "id": "d97f3557"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 얕은 복사\n",
        "import numpy as np\n",
        "d = np.array([1, 2, 3, 4, 5])\n",
        "f = d\n",
        "f[0] = 10\n",
        "\n",
        "print(\"d:\", d)\n",
        "print(\"f:\", f)"
      ],
      "id": "ad73a9b2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "f의 값이 변해도 d값이 변하지 않는 독립적인 변수가 되었음. "
      ],
      "id": "3d88dd31"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 깊은 복사\n",
        "import numpy as np\n",
        "d = np.array([1, 2, 3, 4, 5])\n",
        "f = d.copy()\n",
        "f[0] = 10\n",
        "print(\"d:\", d)\n",
        "\n",
        "print(\"f:\", f)"
      ],
      "id": "fc1b5d88",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "sort()\n",
        "배열을 정렬"
      ],
      "id": "ede94deb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "g = np.array([3, 1, 2])\n",
        "g.sort()\n",
        "print(\"정렬된 배열:\", g)"
      ],
      "id": "c7cb4c3a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "argsort()\n",
        "배열의 원소들을 정렬했을때 인덱스를 반환"
      ],
      "id": "ce5476e7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "h = np.array([3, 1, 2])\n",
        "print(\"정렬된 인덱스:\", h.argsort())"
      ],
      "id": "2441b83e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### NumPy 배열에 apply함수 적용\n",
        "\n",
        "apply_along_axis()  \n",
        "넘파이 배열에 함수를 적용"
      ],
      "id": "803e87b5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "array_3d = np.arange(1, 25).reshape(2, 4, 3).transpose(0, 2, 1)\n",
        "print(array_3d)\n",
        "\n",
        "# 같은 위치에 있는 값들끼리 비교\n",
        "def my_func(x):\n",
        "  return np.min(x)\n",
        "np.apply_along_axis(my_func, axis=0, arr=array_3d)\n",
        "\n",
        "# 같은 깊이의 행별 최소값\n",
        "np.apply_along_axis(my_func, axis=1, arr=array_3d)\n",
        "\n",
        "# 같은 깊이의 열별 최소값\n",
        "np.apply_along_axis(my_func, axis=2, arr=array_3d)"
      ],
      "id": "07b9663c",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}